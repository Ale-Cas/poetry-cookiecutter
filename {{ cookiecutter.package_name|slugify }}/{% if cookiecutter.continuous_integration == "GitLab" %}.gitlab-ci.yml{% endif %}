stages:
  - test
  - {% if cookiecutter.with_fastapi_api|int or cookiecutter.with_streamlit_app|int %}deploy{% else %}publish{% endif %}
{%- if cookiecutter.sentry_dsn %}

variables:
  GIT_DEPTH: 100
{%- endif %}

# Lint and test the package.
Test:
  stage: test
  image: python:3.8-slim
  cache:
    - key:
        files:
          - poetry.lock
      paths:
          - .venv/
    - key: $CI_COMMIT_REF_SLUG
      paths:
        - .mypy_cache/
        - .pytest_cache/
  script:
    - apt-get update && apt-get install --no-install-recommends --yes git
    - pip install --no-input poetry
    {%- if cookiecutter.private_package_repository_name %}
    - poetry config http-basic.{{ cookiecutter.private_package_repository_name|lower }} gitlab-ci-token $CI_JOB_TOKEN
    {%- endif %}
    - poetry config virtualenvs.in-project true
    - poetry install --no-interaction
    - poetry run poe lint
    - poetry run poe test
  coverage: '/^TOTAL.*\s+(\d+\%)$/'
  artifacts:
    exclude:
      - .venv/**/*
    reports:
      cobertura: reports/coverage.xml
      junit:
        - reports/mypy.xml
        - reports/pytest.xml
    untracked: true
    when: always

{% if not cookiecutter.with_fastapi_api|int and not cookiecutter.with_streamlit_app|int -%}
# Publish this package version to a (private) package repository.
Publish:
  stage: publish
  image: python:3.8-slim
  script:
    - pip install --no-input poetry
    {%- if cookiecutter.private_package_repository_name %}
    - poetry config repositories.private "{{ cookiecutter.private_package_repository_url.replace('simple', '') }}"
    - poetry config http-basic.private "gitlab-ci-token" "$CI_JOB_TOKEN"
    - poetry publish --build --repository private
    {%- else %}
    - poetry config http-basic.pypi "__token__" "$POETRY_PYPI_TOKEN_PYPI"
    - poetry publish --build
    {%- endif %}
  only:
    - tags
{%- else -%}
# Build the application as a Docker image and push it to the GitLab registry.
.deploy:
  stage: deploy
  image: docker:stable
  services:
    - docker:stable-dind
  variables:
    DOCKER_IMAGE: $CI_REGISTRY_IMAGE
    DOCKER_REGISTRY: $CI_REGISTRY
    DOCKER_REGISTRY_USER: $CI_REGISTRY_USER
    DOCKER_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
  script:
    - |
      # Compile a list of image tags.
      DOCKER_TAGS=( "$CI_COMMIT_SHORT_SHA" )
      if [[ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]]; then DOCKER_TAGS+=( "latest" ); fi
      if [[ -n $CI_COMMIT_TAG ]]; then DOCKER_TAGS+=( "$CI_COMMIT_TAG" ); fi
      if [[ -n $CI_ENVIRONMENT_NAME ]]; then DOCKER_TAGS+=( "$CI_ENVIRONMENT_NAME" ); fi
      # Build the Docker image with all of the selected tags.
      DOCKER_TAGS_JOINED=${DOCKER_TAGS[@]}
      DOCKER_TAGS_JOINED="--tag $DOCKER_IMAGE:${DOCKER_TAGS_JOINED// / --tag $DOCKER_IMAGE:}"
      DOCKER_BUILDKIT=1 docker build \
        --build-arg SOURCE_BRANCH=$CI_COMMIT_REF_NAME \
        --build-arg SOURCE_COMMIT=$CI_COMMIT_SHA \
        --build-arg SOURCE_TIMESTAMP=$CI_COMMIT_TIMESTAMP \
        {%- if cookiecutter.private_package_repository_name %}
        --secret id=poetry-http-basic-username,env=POETRY_HTTP_BASIC_{{ cookiecutter.private_package_repository_name|upper }}_USERNAME \
        --secret id=poetry-http-basic-password,env=POETRY_HTTP_BASIC_{{ cookiecutter.private_package_repository_name|upper }}_PASSWORD \
        {%- endif %}
        --target app \
        --pull \
        $DOCKER_TAGS_JOINED \
        .
      # Push all the tagged images.
      for DOCKER_TAG in ${DOCKER_TAGS[@]}; do
        docker push "$DOCKER_IMAGE:$DOCKER_TAG"
      done
  when: manual
{% for environment in ["feature", "development", "test", "acceptance", "production"] %}
Deploy ({{ environment }}):
  extends:
    - .deploy
  environment: {{ environment }}
  {%- if environment in ["acceptance", "production"] %}
  only:
    - tags
  {%- endif %}
{% endfor %}
{%- endif %}